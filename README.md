### Вариант 1. Жадный алгоритм для вершинного покрытия

Задача: Реализовать жадный 2-аппроксимационный алгоритм для задачи о вершинном покрытии. Входные данные представляют собой граф, заданный списком ребер. Необходимо найти множество вершин, таких что каждое ребро имеет хотя бы один конец в этом множестве.

Требования:

· Реализовать алгоритм на всех трех языках (Python, C++, Java)

· Проверить корректность решения

· Вывести размер найденного покрытия и само покрытие

· Оценить коэффициент аппроксимации (должен быть ≤ 2)

Входные данные:
Граф с 10 вершинами(0-9) и следующими ребрами:

(0,1),(1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0)



### Объяснение работы алгоритма:

Алгоритм Approx-Vertex-Cover(G):

1. Инициализация — создаем пустое множество для покрытия (C) и копию множества ребер (E')
2. Цикл обработки ребер — пока есть непокрытые ребра:
   · Выбираем произвольное ребро (u, v) из E'
   · Добавляем обе вершины u и v в покрытие C
   · Удаляем из E' все ребра, инцидентные u или v
3. Возврат результата — возвращаем множество C как приближенное вершинное покрытие

Почему алгоритм дает 2-аппроксимацию:

· Каждое выбранное ребро требует минимум одну вершину в оптимальном решении
· Мы выбираем две вершины на ребро, максимум в два раза превышая оптимум
· Таким образом, размер найденного покрытия не более чем в 2 раза превышает размер оптимального покрытия


### Временная сложность жадного алгоритма для вершинного покрытия:
    O(E × (V + E)) в наихудшем случае, где:

    V — число вершин в графе;

    E — число рёбер в графе.

### Пояснение:

Основной цикл выполняется, пока есть необработанные рёбра (максимум E итераций).

### На каждой итерации:

Выбирается одно ребро (O(1) с использованием структуры, например, множества).

Добавляются две вершины в покрытие (O(1)).

Удаляются все рёбра, инцидентные выбранным вершинам.

В худшем случае это требует проверки всех оставшихся рёбер (O(E)).

### Итоговая сложность:

    В наивной реализации с проверкой всех рёбер на каждой итерации: O(E²).

    При использовании эффективных структур данных (например, списков смежности и хеш-таблиц) можно снизить до O(V + E), но в данной реализации остаётся O(E × (V + E)) или O(E²) в плотных графах.

### Коротко о факторах:

    Чем больше рёбер, тем дольше работает алгоритм.

    Плотные графы (E ≈ V²) приводят к квадратичной сложности.

    Алгоритм даёт 2-аппроксимацию, то есть размер найденного покрытия не более чем в 2 раза превышает оптимальный.

    Прост в реализации и эффективен для графов умеренного размера.

    Итоговая сложность — полиномиальная (O(E²)), что приемлемо для многих практических задач.




### Результаты работы программы:

Для входных данных (цикл из 10 вершин):

· Найденное покрытие: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} (все вершины)

· Размер покрытия: 10

· Все ребра покрыты корректно

· Коэффициент аппроксимации: 2.0

· Условие α ≤ 2: выполнено

Анализ результатов:

1. Корректность: Алгоритм гарантированно покрывает все ребра графа
   
2. Качество: Для цикла из n вершин оптимальное покрытие = n/2, наш алгоритм находит все n вершин, что дает коэффициент аппроксимации 2
   
3. Эффективность: Временная сложность O(E), где E — количество ребер
   
4. Практическое применение: Алгоритм прост в реализации и работает быстро даже для больших графов



### Контрольный вопрос 1:

Определение приближенных алгоритмов. Что такое приближенный алгоритм и какова его основная цель в решении NP-сложных задач?

Ответ:
Приближенный алгоритм — это алгоритм, который находит решение оптимизационной задачи, не обязательно оптимальное, но гарантированно близкое к оптимальному по качеству. 

Основная цель приближенных алгоритмов — решение NP-сложных задач, для которых нахождение точного оптимального решения требует экспоненциального времени и практически неосуществимо для больших размеров входных данных.

Ключевые характеристики:

1. Гарантированное качество: Алгоритм гарантирует, что найденное решение будет не хуже, чем в α раз от оптимального (где α — коэффициент аппроксимации)
2. Полиномиальное время: Алгоритм работает за полиномиальное время от размера входных данных
3. Компромисс точность-скорость: Принимается некоторое снижение точности ради приемлемого времени работы

Примеры NP-сложных задач, решаемых приближенными алгоритмами:

· Задача о вершинном покрытии (2-аппроксимация)

· Задача коммивояжера (для метрического TSP — 1.5-аппроксимация)

· Задача о рюкзаке (FPTAS — схема сколь угодно точной аппроксимации)

Значение для практики: Приближенные алгоритмы позволяют решать сложные оптимизационные задачи из реальной жизни (планирование, логистика, проектирование) за разумное время, обеспечивая решения приемлемого качества.

